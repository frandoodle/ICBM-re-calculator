---
title: 'Illustrating the "dynamic depth mixing" method for correcting SOC depth measurements and testing DSM estimates of initial SOC'
author: "Francis Durnin-Vermette"
date: "2023/01/24"
output:
  html_document:
    toc: true
    number_sections: true
    df_print: paged
bibliography: bib.bib
editor_options:
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "doc") })
---

```{r include=FALSE}

library(ggplot2)
library(dplyr)
library(here)
library(stringr)
library(tidyr)

dir.create(tempdir()) #This fixes a bug if the temporary directory is not found

here::i_am("qc_initialc.rmd")
```

```{r, results='hide', message=FALSE, warning=FALSE, include=FALSE}
site_data_all <- readr::read_csv(here("data/lte_master_beta_dec02.csv")) %>%
	mutate(soil_depth = paste0(soil_depth_min_cm,"-",soil_depth_max_cm))
```
The purpose of this report is to 

1. give an overview of how depth measurements from field data can be corrected to the target depth for use in SOC model validation using a "dynamic depth mixing" method, and
2. visualize the realism of initial SOC estimates for Canadian long-term experimental sites.

These estimates were obtained using a digital soil mapping (DSM) method because some sites do not have an initial SOC measurement (meaning before the beginning of the experiment), which is an important parameter in SOC modelling.

# Assumptions

## Depth correction
Many of these experiments did not sample SOC at depths 0-30cm.
We corrected these values using two different algorithms: the naive method, and the dynamic method.

### Naive approach

If we assume the the measured SOC is evenly distributed between 0 and 30cm, we can correct the measured soil depth to 0-30cm using the following equation:

$$
SOC_{30} = SOC_{measured} * \frac{30cm}{max_{depth} - min_{depth}}
$$

### Dynamic approach

However, it might be safer to assume that the top 20cm of soil changes relative to treatment effect, but that the bottom 10cm remains relatively constant.

We can test this assumption by looking at SOC measurements from different depths:

```{r}
site_data_control_comparison <- site_data_all %>%
	mutate(is_control = ifelse(treatment_number == 1, TRUE, FALSE)) %>%
	group_by(Exp_ID, is_control, soil_depth) %>%
	summarise(soc = mean(soc_tha, na.rm=T), sd = sd(soc_tha, na.rm=T)) %>%
	mutate(soc_upper = soc+sd,
				 soc_lower = soc-sd) %>%
	filter(!is.na(is_control)) %>%
	filter(!is.na(soc))
site_data_control_comparison

# Lethbridge is the only site with both control and non-control treatments
# (Control meaning treatment_number == 1)
site_data_control_comparison %>%
	filter(Exp_ID == 4) %>%
ggplot(aes(y=soc, x=soil_depth, fill=is_control)) +
	#facet_wrap(vars(Exp_ID)) +
	geom_col(position="dodge") +
	geom_errorbar(aes(ymin = soc_lower, ymax = soc_upper), position="dodge") +
	ggtitle("Lethbridge") +
	theme_bw()
```

Because there is only data from Lethbridge with complex soil depth sampling and explicit control treatments, it is hard to generalize whether the dynamic depth mixing approach would work better than the naive approach.

In order to correct for SOC following the dynamic method, I follow these steps:

- For each treatment, sum every SOC depth measurement less than or equal to 20cm deep. For instance, sum the measurements of 0-7.5cm and 7.5-15cm to calculate 0-15cm. Take this value and correct it to 0-20cm
- Take the control value from the same experiment, find the single depth measurement closest to 20-30cm, and correct this measurement to 20-30cm
	- If there is no control treatment for the current experimental group, instead use the **first** SOC value from the current treatment.
- Sum the 0-20cm treatment SOC and the 20-30cm control SOC to get a corrected 0-30cm SOC estimate.



In order to apply depth corrections, we used the following equation:
$$
SOC_{depth_{target}} = SOC_{measured} * \frac{depth_{target}}{depth_{measurement_{max}} - depth_{measurement_{min}}}
$$

In theory, the final value is a corrected SOC where 0-20cm are affected by changes in the treatment, and 20-30cm is not affected by changes in treatment.

## Initial C year
In order to visualize the change in SOC between the initial C estimate and the first measurement of SOC in the experiment, we need to decide on a year that the initial SOC estimate represents.
Here is my approach:

- If the first SOC measurement in the experiment is after or during 2000, then I set the initial SOC to be the value in 1999.
- If the first SOC measurement in the experiment is before 2000, then I assume that the initial C represents the SOC for the year *before* the first SOC measurement.

# Testing SOC corrections (dynamic depth correction vs. naive correction)

First we need to handle depth correction.
One problem we run into with the data is that sometimes there are multiple ways to arrive at 0-30cm from the same site.
For instance, some treatments in Lethbridge measure 0-7.5, 7.5-15, 15-30, and 0-15.
In this case, there are two ways to arrive at 0-30: either 0-7.5 + 7.5-15 + 15-30, or just 0-15 + 15-30.

In order to handle this, I made a function `make_depth_groups` which makes a dataset with both groupings in order to arrive at 0-30cm. In the above example, this duplicates the 15-30cm measurements since they are used in both groupings.

```{r}
make_depth_groups
```


```{r results='hide', message=FALSE, warning=FALSE}
site_data_corrected_depth_groups <- site_data_all %>%
	full_join(initialc_dsm, by=c("location_name")) %>%
	full_join(initialc_cmods, by="location_name") %>%
	select(Exp_ID, location_name, treatment_number,treatment_name, year_name, replication_number, soil_depth, soil_depth_min_cm, soil_depth_max_cm,
				 initial_soc_year,
				 initial_dataset = initial_soc_tha,
				 soc_tha) %>%
	filter(!is.na(soc_tha)) %>%
	# Get the mean for field_name, replication_number, and block
	group_by(Exp_ID, location_name, year_name, treatment_number, treatment_name, soil_depth_min_cm, soil_depth_max_cm, initial_soc_year) %>%
	summarise(across(initial_dataset:soc_tha, mean)) %>%
	group_by(Exp_ID, location_name, year_name, treatment_number, treatment_name) %>%
	group_split() %>%
	purrr::map(~make_depth_groups(.)) %>%
	bind_rows
```

Now we add different estimates of initial C. These come from the digital soil mapping (DSM) estimates and the CMods repository.

We assume that the DSM estimates are from the year 1999 or earlier, and if the first measures SOC event for that experiment is before 1999 we choose the first year before that measurement as the initial SOC estimate year.


```{r}
initialc_dsm <- readr::read_csv(here("data/lte_soc_30_cm_dsm.csv")) %>%
	mutate(location_name = location_n) %>%
	select(location_name, initial_dsm = `Can_SOC30 (Mg ha-1)`) %>%
	unique
initialc_cmods <- readr::read_csv(here("data/ExptSiteList.csv")) %>%
	select(location_name, initial_cmods = init_soc) %>%
	unique

site_data_corrected <- site_data_corrected_depth_groups %>%
	full_join(initialc_dsm, by=c("location_name")) %>%
	full_join(initialc_cmods, by="location_name") %>%
	select(Exp_ID, location_name, treatment_number,treatment_name, year_name, soil_depth, soil_depth_min_cm, soil_depth_max_cm,
				 soc_tha, initial_dataset, initial_dsm, initial_cmods, initial_soc_year) %>%
	# Set the initial C to either be 1 year before the first year in the experiment, or 1999 (maximum start date).
	mutate(initial_soc_year_dsm = ifelse(min(year_name) < 2000, min(year_name)-1, 1999))

```

## Ellerslie 

```{r}
site_data_corrected %>%
	select(Exp_ID, location_name, treatment_name, year_name,
				 soc_30cm_naive, soc_30cm_dynamic_control
				 ) %>%
	filter(location_name == "Ellerslie") %>%
	filter(!is.na(soc_30cm_naive)) %>%
	filter(treatment_number == 1 |
				 	treatment_name == "F25NS")
```


Let's see if our new method of estimating SOC at 30cm works.

For year = 2009:

### Naive

Treatment 0-30cm = 123.3200 * (30/20) = **184.98**

### Dynamic

```{r}
site_data_corrected %>%
	select(Exp_ID, location_name, treatment_name, year_name,
				 soc_30cm_naive, soc_30cm_dynamic_control
				 ) %>%
	filter(location_name == "Ellerslie") %>%
	filter(!is.na(soc_30cm_naive)) %>%
	filter(treatment_number == 1 |
				 	treatment_name == "F25NS",
				 year_name == 2009)
```

## Lethbridge 

```{r}

site_data_corrected %>%
	select(Exp_ID, location_name, treatment_name, year_name,
				 soc_30cm_naive, soc_30cm_dynamic_control
				 ) %>%
	filter(location_name == "Lethbridge") %>%
	filter(!is.na(soc_30cm_naive)) %>%
	filter(treatment_number == 1 |
				 	treatment_name == "Fw-Wt I")
```

For year = 1992:

### Naive
Treatment 0-30cm = mean(56.50, 116.00, 117.50) = **96.66667**

### Dynamic

```{r}
site_data_corrected %>%
	select(Exp_ID, location_name, treatment_name, year_name,
				 soc_30cm_naive, soc_30cm_dynamic_control
				 ) %>%
	filter(location_name == "Lethbridge") %>%
	filter(!is.na(soc_30cm_naive)) %>%
	filter(treatment_number == 1 |
				 	treatment_name == "Fw-Wt I",
				 year_name == 1992)
```

# Graphing

## All sites

Looking at all the sites, we can see that the DSM initial estimates seem to generally agree well with measured SOC values.

Additionally, it appears that in many cases (e.g. Melfort, Beaverlodge, Scott) the dynamic SOC estimation method leads to SOC values that seem more realistic within the context of the DSM initial C estimates.

```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width=15, fig.height=15}
site_data_all_joined %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
	pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
	ggplot(aes(x=year_name)) +
	geom_point(aes(y=soc, color=soc_method), alpha=0.4) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(location_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	theme(aspect.ratio = 1)
```

### Ellerslie

There are large differences between the initial C estimates for Ellerslie.
The CMods estimates seem to cohere with the measured data best, but the DSM estimates could be made more realistic if the initial values were assumed to be from 10 years before 1999 (shown in blue).

```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
ellerslie_increase <- site_data_all_joined %>%
	filter(location_name == "Ellerslie") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_naive),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+"),
				 
				 recommended_initial_soc_year = initial_soc_year-10,
				 recommended_increase_per_year = increase / (first_soc_year - recommended_initial_soc_year),
				 recommended_fraction_increase_per_year = recommended_increase_per_year/initial_dsm)

site_data_all_joined %>%
	filter(location_name == "Ellerslie") %>%
	# Get mean values between replicates and soil depth measurements. Lethbridge requires a particularly difficult grouping scheme
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
	pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
	ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=ellerslie_increase, aes(y=initial_dsm, x=initial_soc_year, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=ellerslie_increase, aes(x=first_soc_year, y=first_soc, hjust=ifelse(first_soc_year < 1990, -0.1, 1.1), label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red") +
	geom_segment(data=ellerslie_increase, aes(y=initial_dsm, x=recommended_initial_soc_year, yend=first_soc, xend=first_soc_year), color="blue",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=ellerslie_increase, aes(x=recommended_initial_soc_year, y=initial_dsm, label=paste0(sign,round(recommended_increase_per_year, 2)," Mg/ha/yr\n",sign,round(recommended_fraction_increase_per_year,2)*100, "%/yr")),
						color="blue", hjust=-0.1, vjust=0) +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle("Ellerslie") +
	theme(aspect.ratio = 1)
```

### Harrow
All three estimates of initial C are realistic for Harrow.
The DSM estimates are the furthest away from the first measured value, but only represents a 4% increase / year, which is still within reason.
```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
harrow_increase <- site_data_all_joined %>%
	filter(location_name == "Harrow") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_naive),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+"))

site_data_all_joined %>%
	filter(location_name == "Harrow") %>%
	# Get mean values between replicates and soil depth measurements. Lethbridge requires a particularly difficult grouping scheme
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
	pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
	ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=harrow_increase, aes(y=initial_dsm, x=initial_soc_year, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=harrow_increase, aes(x=first_soc_year, y=first_soc, hjust=ifelse(first_soc_year < 1990, -0.1, 1.1), label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red") +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle("Harrow") +
	theme(aspect.ratio = 1)
```


### Lethbridge

The DSM values for Lethbridge work well with the measured values, and are an improvement over the CMods initial estimates.
The difference between the initial value and the first measured value rarely exceeds 2%/year.

Lethbridge is an instance of a site where SOC was measured at depths 0-7.5, 0-15, 7.5-15, and 15-30cm.
In every case, SOC at 0-30cm was gap-filled using the above equation.
```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
lethbridge_increase <- site_data_all_joined %>%
	filter(location_name == "Lethbridge") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_naive),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+"))

site_data_all_joined %>%
	filter(location_name == "Lethbridge") %>%
	# Get mean values between replicates and soil depth measurements. Lethbridge requires a particularly difficult grouping scheme
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
	pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
	ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=lethbridge_increase, aes(y=initial_dsm, x=initial_soc_year, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=lethbridge_increase, aes(x=first_soc_year, y=first_soc, hjust=ifelse(first_soc_year < 1990, -0.1, 1.1), label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red") +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle("Lethbridge") +
	theme(aspect.ratio = 1)
```

### Ottawa

The DSM initial C estimate does not work as well for our Ottawa data - there are large 40-50% increases in SOC from the initial C to the first measured value.
I suspect this is because I am setting the initial C year to the year before the first measurement.

These values would work better if we consider this to be the initial C ~10 years before the beginning of the experiment. This is shown in blue.

The CMods initial estimates are a bit more realistic, because they show a sudden SOC decrease following the beginning of the experiment.
```{r, message=FALSE, warning=FALSE, echo=FALSE}
ottawa_increase <- site_data_all_joined %>%
	filter(location_name == "Ottawa") %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_naive),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+"),
				 
				 recommended_initial_soc_year = initial_soc_year-10,
				 recommended_increase_per_year = increase / (first_soc_year - recommended_initial_soc_year),
				 recommended_fraction_increase_per_year = recommended_increase_per_year/initial_dsm)

site_data_all_joined %>%
	filter(location_name == "Ottawa") %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
	pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
	ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=ottawa_increase, aes(y=initial_dsm, x=initial_soc_year, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=ottawa_increase, aes(x=first_soc_year, y=first_soc, label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red", hjust=-0.1) +
	geom_segment(data=ottawa_increase, aes(y=initial_dsm, x=recommended_initial_soc_year, yend=first_soc, xend=first_soc_year), color="blue",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=ottawa_increase, aes(x=recommended_initial_soc_year, y=initial_dsm, label=paste0(sign,round(recommended_increase_per_year, 2)," Mg/ha/yr\n",sign,round(recommended_fraction_increase_per_year,2)*100, "%/yr")),
						color="blue", hjust=-0.1, vjust=0) +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle("Ottawa") +
	theme(aspect.ratio = 1)
```

### Scott

The DSM initial C values do not work very well for the Scott experiments.
These are very large increases between the initial C value and the first measurement of SOC.

More reasonable increases (about +5%/year) are seen if we instead assume that the initial C represents the case 15 years before the first SOC measurement in the experiment (shown in blue).

SOC measurements in Scott are taken at depths 0-7.5, 7.5-15, and 0-15cm.
We gap-filled these values to 0-30cm using the equation above.
```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
scott_increase <- site_data_all_joined %>%
	filter(location_name == "Scott") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_naive),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+"),
				 
				 recommended_initial_soc_year = initial_soc_year-15,
				 recommended_increase_per_year = increase / (first_soc_year - recommended_initial_soc_year),
				 recommended_fraction_increase_per_year = recommended_increase_per_year/initial_dsm)

site_data_all_joined %>%
	filter(location_name == "Scott") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
		pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%

	ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=scott_increase, aes(y=initial_dsm, x=initial_soc_year, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=scott_increase, aes(x=first_soc_year, y=first_soc, label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red", hjust=-0.1, size=3) +
	geom_segment(data=scott_increase, aes(y=initial_dsm, x=recommended_initial_soc_year, yend=first_soc, xend=first_soc_year), color="blue",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=scott_increase, aes(x=recommended_initial_soc_year, y=initial_dsm, label=paste0(sign,round(recommended_increase_per_year, 2)," Mg/ha/yr\n",sign,round(recommended_fraction_increase_per_year,2)*100, "%/yr")),
						color="blue", hjust=-0.1, vjust=0, size=3) +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle("Scott") +
	theme(aspect.ratio = 1)
```

### Swift Current New

The DSM initial C values do not work very well for the Swift Current New experiments, however they are large improvements over the CMods estimates.
These are very large increases between the initial C value and the first measurement of SOC.

More realistic values of % C increase (about 2-3% MgC/ha/yr) if we assume that the initial C value represents the SOC at 10 years before the beginning of the experiment (shown in blue).
```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
swiftcurrentnew_increase <- site_data_all_joined %>%
	filter(location_name == "Swift Current New") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_naive),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+"),
				 
				 recommended_initial_soc_year = initial_soc_year-10,
				 recommended_increase_per_year = increase / (first_soc_year - recommended_initial_soc_year),
				 recommended_fraction_increase_per_year = recommended_increase_per_year/initial_dsm) %>%
	summarise_all(first)

site_data_all_joined %>%
	filter(location_name == "Swift Current New") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
	
		pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=swiftcurrentnew_increase, aes(y=initial_dsm, x=initial_soc_year, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=swiftcurrentnew_increase, aes(x=first_soc_year, y=first_soc, label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red", hjust=-0.1) +
	geom_segment(data=swiftcurrentnew_increase, aes(y=initial_dsm, x=recommended_initial_soc_year, yend=first_soc, xend=first_soc_year), color="blue",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=swiftcurrentnew_increase, aes(x=recommended_initial_soc_year, y=initial_dsm, label=paste0(sign,round(recommended_increase_per_year, 2)," Mg/ha/yr\n",sign,round(recommended_fraction_increase_per_year,2)*100, "%/yr")),
						color="blue", hjust=-0.1, vjust=0) +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle("Swift Current New") +
	theme(aspect.ratio = 1)
```

### Swift Current Old

The DSM initial C estimates generally work well for Swift Current Old, and are also large improvements over the CMods estimates.
Most treatments see increases of about +1-4% MgC/ha/yr SOC from the initial C estimate to the first year of SOC sampling.

There are, however, some instances where this increase is in the range of 10-15%, which is less realistic.
These instances of large increases are the result of my assumption that the initial C is one year before the beginning of the experiment.
If we follow another assumption to decide the initial C year, then we might achieve more realistic changes in SOC at the beginning of the experiment.

Using the dynamic method to correct SOC measurements boosts the SOC levels in these fields. This causes the initial SOC estimates to seem more unrealistic.

```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
swiftcurrentold_increase <- site_data_all_joined %>%
	filter(location_name == "Swift Current Old") %>%
	group_by_all() %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_naive),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+")) %>%
	summarise_all(first)

site_data_all_joined %>%
	filter(location_name == "Swift Current Old") %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dynamic_control"), names_to="soc_method", values_to="soc") %>%
		pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=swiftcurrentold_increase, aes(y=initial_dsm, x=initial_soc_year, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=swiftcurrentold_increase, aes(hjust=ifelse(first_soc_year < 2000, -0.1, 1.1), x=first_soc_year, y=first_soc, label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red") +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle("Swift Current Old") +
	theme(aspect.ratio = 1)
```