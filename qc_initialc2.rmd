---
title: 'Illustrating the "dynamic depth mixing" method for correcting SOC depth measurements and testing DSM estimates of initial SOC'
author: "Francis Durnin-Vermette"
date: "2023/01/24"
output:
  html_document:
    toc: true
    number_sections: true
    df_print: paged
bibliography: bib.bib
editor_options:
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "doc") })
---

```{r include=FALSE}

library(ggplot2)
library(dplyr)
library(here)
library(stringr)
library(tidyr)

dir.create(tempdir()) #This fixes a bug if the temporary directory is not found

source("stack_overflow_question.r")

here::i_am("qc_initialc.rmd")
```

```{r, results='hide', message=FALSE, warning=FALSE, include=FALSE}
site_data_all <- readr::read_csv(here("data/lte_master_beta_dec02.csv")) %>%
	mutate(soil_depth = paste0(soil_depth_min_cm,"-",soil_depth_max_cm))

initialc_dsm <- readr::read_csv(here("data/lte_soc_30_cm_dsm.csv")) %>%
	mutate(location_name = location_n) %>%
	select(location_name, initial_dsm = `Can_SOC30 (Mg ha-1)`) %>%
	unique
initialc_cmods <- readr::read_csv(here("data/ExptSiteList.csv")) %>%
	select(location_name, initial_cmods = init_soc) %>%
	unique
```
The purpose of this report is to 

1. give an overview of how depth measurements from field data can be corrected to the target depth for use in SOC model validation using a "dynamic depth mixing" method, and
2. visualize the realism of initial SOC estimates for Canadian long-term experimental sites.

These estimates were obtained using a digital soil mapping (DSM) method because some sites do not have an initial SOC measurement (meaning before the beginning of the experiment), which is an important parameter in SOC modelling.

# Assumptions

## Depth correction
Many of these experiments did not sample SOC at depths 0-30cm.
We corrected these values using two different algorithms: the naive method, and the dynamic method.

### Naive approach

If we assume the the measured SOC is evenly distributed between 0 and 30cm, we can correct the measured soil depth to 0-30cm using the following equation:

$$
SOC_{30} = SOC_{measured} * \frac{30cm}{max_{depth} - min_{depth}}
$$

### Dynamic approach

However, it might be safer to assume that the top 20cm of soil changes relative to treatment effect, but that the bottom 10cm remains relatively constant.

We can test this assumption by looking at SOC measurements from different depths:

```{r}
site_data_control_comparison <- site_data_all %>%
	mutate(is_control = ifelse(treatment_number == 1, TRUE, FALSE)) %>%
	group_by(Exp_ID, is_control, soil_depth) %>%
	summarise(soc = mean(soc_tha, na.rm=T), sd = sd(soc_tha, na.rm=T)) %>%
	mutate(soc_upper = soc+sd,
				 soc_lower = soc-sd) %>%
	filter(!is.na(is_control)) %>%
	filter(!is.na(soc))
site_data_control_comparison

# Lethbridge is the only site with both control and non-control treatments
# (Control meaning treatment_number == 1)
site_data_control_comparison %>%
	filter(Exp_ID == 4) %>%
ggplot(aes(y=soc, x=soil_depth, fill=is_control)) +
	#facet_wrap(vars(Exp_ID)) +
	geom_col(position="dodge") +
	geom_errorbar(aes(ymin = soc_lower, ymax = soc_upper), position="dodge") +
	ggtitle("Lethbridge") +
	theme_bw()
```

Because there is only data from Lethbridge with complex soil depth sampling and explicit control treatments, it is hard to generalize whether the dynamic depth mixing approach would work better than the naive approach.

In order to correct for SOC following the dynamic method, I follow these steps:

- For each treatment, sum every SOC depth measurement less than or equal to 20cm deep. For instance, sum the measurements of 0-7.5cm and 7.5-15cm to calculate 0-15cm. Take this value and correct it to 0-20cm
- Take the control value from the same experiment, find the single depth measurement closest to 20-30cm, and correct this measurement to 20-30cm
	- If there is no control treatment for the current experimental group, instead use the **first** SOC value from the current treatment.
- Sum the 0-20cm treatment SOC and the 20-30cm control SOC to get a corrected 0-30cm SOC estimate.



In order to apply depth corrections, we used the following equation:
$$
SOC_{depth_{target}} = SOC_{measured} * \frac{depth_{target}}{depth_{measurement_{max}} - depth_{measurement_{min}}}
$$

In theory, the final value is a corrected SOC where 0-20cm are affected by changes in the treatment, and 20-30cm is not affected by changes in treatment.

## Initial C year
In order to visualize the change in SOC between the initial C estimate and the first measurement of SOC in the experiment, we need to decide on a year that the initial SOC estimate represents.
Here is my approach:

- If the first SOC measurement in the experiment is after or during 2000, then I set the initial SOC to be the value in 1999.
- If the first SOC measurement in the experiment is before 2000, then I assume that the initial C represents the SOC for the year *before* the first SOC measurement.

# Testing SOC corrections (dynamic depth correction vs. naive correction)

First we need to handle depth correction.
One problem we run into with the data is that sometimes there are multiple ways to arrive at 0-30cm from the same site.
For instance, some treatments in Lethbridge measure 0-7.5, 7.5-15, 15-30, and 0-15.
In this case, there are two ways to arrive at 0-30: either 0-7.5 + 7.5-15 + 15-30, or just 0-15 + 15-30.

In order to handle this, I made a function `make_depth_groups` which makes a dataset with both groupings in order to arrive at 0-30cm. In the above example, this duplicates the 15-30cm measurements since they are used in both groupings.

```{r}
make_depth_groups
```


```{r results='hide', message=FALSE, warning=FALSE}
site_data_depth_groups <- site_data_all %>%
	full_join(initialc_dsm, by=c("location_name")) %>%
	full_join(initialc_cmods, by="location_name") %>%
	select(Exp_ID, location_name, treatment_number,treatment_name, year_name, replication_number, soil_depth, soil_depth_min_cm, soil_depth_max_cm,
				 initial_soc_year,
				 initial_dataset = initial_soc_tha,
				 soc_tha) %>%
	filter(!is.na(soc_tha)) %>%
	# Get the mean for field_name, replication_number, and block
	group_by(Exp_ID, location_name, year_name, treatment_number, treatment_name, soil_depth_min_cm, soil_depth_max_cm, initial_soc_year) %>%
	summarise(across(initial_dataset:soc_tha, mean)) %>%
	group_by(Exp_ID, location_name, year_name, treatment_number, treatment_name) %>%
	group_split() %>%
	purrr::map(~make_depth_groups(.)) %>%
	bind_rows

site_data_depth_groups_summed <- site_data_depth_groups %>%
	group_by(Exp_ID, location_name, year_name, treatment_number, treatment_name, initial_soc_year, combination_group, lowest_depth = k) %>%
	summarise(soc_tha_lowest_depth = sum(soc_tha),
						initial_dataset = mean(initial_dataset))
```

Now we add different estimates of initial C. These come from the digital soil mapping (DSM) estimates and the CMods repository.

We assume that the DSM estimates are from the year 1999 or earlier, and if the first measures SOC event for that experiment is before 1999 we choose the first year before that measurement as the initial SOC estimate year.


```{r}
site_data_joined <- site_data_depth_groups_summed %>%
	full_join(initialc_dsm, by=c("location_name")) %>%
	full_join(initialc_cmods, by="location_name") %>%
	select(Exp_ID, location_name, treatment_number,treatment_name, year_name, lowest_depth,
				 soc_tha_lowest_depth, initial_dataset, initial_dsm, initial_cmods, initial_soc_year) %>%
	# Set the initial C to either be 1 year before the first year ever measured for that site, or 1999 (maximum start date).
	group_by(Exp_ID, location_name) %>%
	mutate(initial_soc_year_dsm = ifelse(min(year_name) < 2000, min(year_name)-1, 1999))

```

Now, in circumstances where 0-30cm is measured, we can just use this number.
However, if less than 30cm is measured in total, then we need to perform correction.

In order to do this, we check whether the lowest measured depth is lower than 30cm, and if it is then we take the missing amount using either the DSM or CMods estimates.

```{r}
site_data_corrected <- site_data_joined %>%
	mutate(lowest_depth_difference = 30 - lowest_depth,
				 soc_dsm_lowest_depth = initial_dsm * (lowest_depth_difference/30),
				 soc_30cm_dsm = ifelse(lowest_depth_difference >= 0,
				 									soc_tha_lowest_depth+soc_dsm_lowest_depth,
				 									soc_tha_lowest_depth*(30/lowest_depth))) %>%
	mutate(soc_30cm_naive = soc_tha_lowest_depth * (30/lowest_depth))
```

## Lethbridge 

```{r}
site_data_corrected %>%
	select(Exp_ID, location_name, treatment_name, year_name,
				 initial_dsm, 
				 soc_30cm_naive, soc_30cm_dsm
				 ) %>%
	filter(location_name == "Lethbridge, Alberta") %>%
	filter(!is.na(soc_30cm_naive)) %>%
	filter(treatment_name == "Fw-Wt I")
```

For year = 1992:

SOC was measured at 0-7.5, 7.5-15, and 15-30cm for this year.

### Naive

Treatment 0-30cm = **101.500**

### Dynamic

There is no difference between the dynamic approach and the naive approach because 30cm was measured in total.

## Ellerslie 

```{r}
site_data_corrected %>%
	select(Exp_ID, location_name, treatment_name, year_name,
				 initial_dsm,
				 soc_30cm_naive, soc_30cm_dsm
				 ) %>%
	filter(location_name == "Ellerslie, Alberta") %>%
	filter(!is.na(soc_30cm_naive)) %>%
	filter(treatment_name == "F25NS")
```


Let's see if our new method of estimating SOC at 30cm works.

For year = 2009:

### Naive

Treatment 0-20cm = 123.3200

Treatment 0-30cm = 123.3200 * (30/20) = **184.98**

### Dynamic

Treatment 0-20cm = 123.3200

DSM Initial 20-30cm = 131.9	* (10/30) = 43.96667

Treatment 0-30cm = 123.3200 * (30/20) = **167.2867**

It looks like for these sites, our dynamic approach did work in theory since Lethbridge, for which SOC was measured from 0-30cm, did not change between a naive and dynamic approach, whereas Ellerslie, which was only measured down to 20cm, did see a change.

Using the dynamic approach in Ellerslie decreased the measured SOC stock by almost 10%, which is quite significant. Since the 20-30cm in Ellerslie has never been measured, we have no way to test which approach is more accurate.
# Graphing

## All sites

Looking at all the sites, we can see that the DSM initial estimates seem to generally agree well with measured SOC values.

Additionally, it appears that in many cases (e.g. Ellerslie, Melfort, Scott) the dynamic SOC estimation method leads to SOC values that seem more realistic within the context of the DSM initial C estimates.

```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=7}
site_data_corrected %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dsm"), names_to="soc_method", values_to="soc") %>%
	pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
	ggplot(aes(x=year_name)) +
	geom_point(aes(y=soc, color=soc_method), alpha=0.4) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year_dsm), color="red") +
	theme_bw() +
	facet_wrap(vars(location_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	theme(aspect.ratio = 1)
```

I will analyze major sites in more depth, but an overview of the DSM initial estimates + dynamic depth correction technique compared to the CMods initial estimates + naive depth correction can be seen in the following graph:
```{r}
bb <- site_data_corrected %>%
	filter(!(treatment_name %in% c("NT", "CT", "NT", "NA"))) %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	group_by(location_name, treatment_name) %>%
	mutate(dsm_first_soc = first(soc_30cm_dsm),
				 dsm_first_soc_year = initial_soc_year_dsm,
				 dataset_first_soc = first(soc_30cm_naive),
				 dataset_first_soc_year = initial_soc_year,
				 
				 `DSM + Dynamic` = initial_dsm - dsm_first_soc,
				 `CMods + Naive` = initial_cmods - dataset_first_soc) %>%
pivot_longer(c("DSM + Dynamic", "CMods + Naive"), names_to="method", values_to="diff") %>%
	select(location_name, treatment_name, method, diff) %>%
	group_by(location_name, method) %>%
	summarise(diff = mean(diff))

ggplot(bb, aes(x=location_name, y=diff, fill=method)) +
	geom_col(position = "dodge") +
	ylab("[Initial estimate] - [First measured SOC] (Mg C/ha)") +
	theme_bw() +
	theme(axis.text.x = element_text(angle = -90))

```


```{r include=FALSE}
make_arrow_plot <- function(location) 
{
	ellerslie_increase <- site_data_corrected %>%
	filter(location_name == location) %>%
	filter(!(treatment_name %in% c("NT", "CT", "NT", "NA"))) %>%
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	group_by(treatment_name) %>%
	mutate(first_soc = first(soc_30cm_dsm),
				 first_soc_year = first(year_name)) %>%
	select(treatment_name, first_soc, first_soc_year, initial_dsm, initial_soc_year_dsm) %>%
	unique %>%
	mutate(increase = first_soc - initial_dsm,
				 increase_per_year = increase / (first_soc_year - initial_soc_year_dsm),
				 fraction_increase = increase/initial_dsm,
				 fraction_increase_per_year = fraction_increase / (first_soc_year - initial_soc_year_dsm),
				 sign = ifelse(fraction_increase_per_year<0, "-", "+"),
				 
				 recommended_initial_soc_year = initial_soc_year_dsm-10,
				 recommended_increase_per_year = increase / (first_soc_year - recommended_initial_soc_year),
				 recommended_fraction_increase_per_year = recommended_increase_per_year/initial_dsm)

site_data_corrected %>%
	filter(location_name == location) %>%
	filter(!(treatment_name %in% c("NT", "CT", "NT", "NA"))) %>%
	# Get mean values between replicates and soil depth measurements. Lethbridge requires a particularly difficult grouping scheme
	group_by_all() %>%
	summarise_all(mean) %>%
	summarise_all(mean) %>%
	pivot_longer(c("soc_30cm_naive", "soc_30cm_dsm"), names_to="soc_method", values_to="soc") %>%
	pivot_longer(c("initial_dsm", "initial_cmods"), names_to="initial_method", values_to="initial") %>%
	ggplot(aes(x=year_name, y=soc_30cm_naive)) +
	geom_segment(data=ellerslie_increase, aes(y=initial_dsm, x=initial_soc_year_dsm, yend=first_soc, xend=first_soc_year), color="red",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=ellerslie_increase, aes(x=first_soc_year, y=first_soc, hjust=ifelse(first_soc_year < 1990, -0.1, 1.1), label=paste0(sign,round(increase_per_year, 2)," Mg/ha/yr\n",sign,round(fraction_increase_per_year,2)*100, "%/yr")),
						color="red") +
	geom_segment(data=ellerslie_increase, aes(y=initial_dsm, x=recommended_initial_soc_year, yend=first_soc, xend=first_soc_year), color="blue",
							 arrow = arrow(length = unit(0.1, "inches"))) +
	geom_text(data=ellerslie_increase, aes(x=recommended_initial_soc_year, y=initial_dsm, label=paste0(sign,round(recommended_increase_per_year, 2)," Mg/ha/yr\n",sign,round(recommended_fraction_increase_per_year,2)*100, "%/yr")),
						color="blue", hjust=-0.1, vjust=0) +
	geom_point(aes(y=soc, color=soc_method), alpha=0.7) +
	geom_point(aes(y=initial, shape=initial_method, x=initial_soc_year_dsm), color="red") +
	theme_bw() +
	facet_wrap(vars(treatment_name)) +
	ylab("SOC (Mg/ha)") +
	xlab("Year") +
	ggtitle(location) +
	theme(aspect.ratio = 1)
}
```


### Ellerslie

There are large differences between the initial C estimates for Ellerslie.
The CMods estimates seem to cohere with the measured data best, but the DSM estimates could be made more realistic if the initial values were assumed to be from 10 years before 1999 (shown in blue).

```{r, message=FALSE, warning=FALSE, fig.width = 6, fig.height = 6, echo=FALSE}
make_arrow_plot("Ellerslie, Alberta")
```

### Harrow
Both estimates of initial C are realistic for Harrow.
The DSM estimates are the furthest away from the first measured value, but only represents a 4% increase / year, which is still within reason.
```{r, message=FALSE, warning=FALSE, fig.width = 6, fig.height = 6, echo=FALSE}
make_arrow_plot("Harrow, Ontario")
```


### Lethbridge

The DSM values for Lethbridge work well with the measured values, and are an improvement over the CMods initial estimates.
The difference between the initial value and the first measured value are generally +/- 4%.
```{r, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 8, echo=FALSE}
make_arrow_plot("Lethbridge, Alberta")
```

### Ottawa

The DSM initial C estimate does not work as well for our Ottawa data - there are large 40-50% increases in SOC from the initial C to the first measured value.
I suspect this is because I am setting the initial C year to the year before the first measurement.

These values would work better if we consider this to be the initial C ~10 years before the beginning of the experiment. This is shown in blue.

The CMods initial estimates are a bit more realistic, because they show a sudden SOC decrease following the beginning of the experiment.
```{r, message=FALSE, warning=FALSE, echo=FALSE}
make_arrow_plot("Ottawa, Ontario")
```

### Scott

The DSM initial C values do not work very well for the Scott experiments.
These are very large increases between the initial C value and the first measurement of SOC.

More reasonable increases (about +5%/year) are seen if we instead assume that the initial C represents the case 15 years before the first SOC measurement in the experiment (shown in blue).

Additionally, the dynamic approach significantly improves the reasonability of the DSM initial estimates, because the measured SOC is decreased by about 15% compared to the naive approach.
```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
make_arrow_plot("Scott, Saskatchewan")
```

### Swift Current New

The DSM initial C values work very well for the Swift Current New experiments, and they are large improvements over the CMods estimates.

Additionally, the dynamic approach to SOC correction seems to agree much better with the DSM estimates compared to the naive approach.
```{r, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 8, echo=FALSE}
make_arrow_plot("Swift Current New")
```

### Swift Current Old

The DSM initial C estimates generally work well for Swift Current Old, and are also large improvements over the CMods estimates.
Most treatments see increases of about +1-4% MgC/ha/yr SOC from the initial C estimate to the first year of SOC sampling.

There are, however, some instances where this increase is in the range of 10-15%, which is less realistic.
These instances of large increases are the result of my assumption that the initial C is one year before the beginning of the experiment.

Using the dynamic method to correct SOC measurements is completely equivalent to using the naive approach.

```{r, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10, echo=FALSE}
make_arrow_plot("Swift Current Old")
```