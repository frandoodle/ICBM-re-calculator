---
title: "ICBM r~e~ calculator"
author: "Francis Durnin-Vermette"
date: "2022/10/31"
output:
  html_notebook:
    toc: true
    number_sections: true
    df_print: paged
bibliography: re.bib
editor_options:
  chunk_output_type: inline
---

```{r include=FALSE}
library(ggplot2)
library(knitr)
library(dplyr)
library(geojson)
library(tibble)
library(purrr)
library(stringr)
library(here)

source("re_functions.r")

here::i_am("re_notebook.rmd")
```

# Climate data
We use the monthly climate normals that are shipped with Holos V4 in order to make our first calculations.

To use these, we need to specify an SLC polygon.
We arbitrarily choose SLC poly #1001009 for this.
```{r}
slc = 1001009
climate_test_norms1 <- readr::read_csv("climate/climateNorms_by_poly_1980_2010.csv") %>%
	filter(SLC == slc)
climate_test_norms1 %>%
	kable(caption="Climate normals for SLC polygon 1001009 for the period 1980 - 2010.")
```

## Test input data
For our first test, let's say our crop is an annual with Yield = 3000.
```{r}
climate_data_monthly <- climate_test_norms1

daily_input_test <- tibble(
	JulianDay = 1:365,
	Yield = rep(3000, 365),
	perennial = rep(FALSE, 365),
	SoilOrganicC_Percent = rep(12, 365),
	ClayContent = rep(0.05, 365),
	SandContent = rep(0.2, 365)
) %>%
	rowwise() %>%
	#add climate data to the input thing
	mutate(Tavg = filter(climate_data_monthly, month==ceiling(JulianDay/30.4375))$Tavg,
				 PREC = filter(climate_data_monthly, month==ceiling(JulianDay/30.4375))$PREC,
				 PET = filter(climate_data_monthly, month==ceiling(JulianDay/30.4375))$PET) %>%
	ungroup()
```



# Green area index (GAI) dynamics

## Eq. 2.2.1-1 through Eq. 2.2.1-3
```{r}
GAI_return <- calculateGAI(daily_input_test)
GAI_return
GAI <- GAI_return[["GAI"]]
```

Where
GAImax is Maximum amplitude of green area index, 
Yield is Crop yield (kg dry matter ha-1, database default or user specific),
MidSeason is Median day of growing season (Julian day),
EmergenceDay is Day of crop emergence (Julian day),
RipeningDay is Day of crop ripening (Julian day),
GAI is Green area index,
JulianDay is Day (Julian day), and
Variance is Width of distribution function.

# Water content at wilting point and field capacity

## Eq. 2.2.1-4 through Eq. 2.2.1-10
```{r}
WaterContent_return <- calculateWaterContent(daily_input_test)
WaterContent_return
WiltingPoint <- WaterContent_return[["WiltingPoint"]]
FieldCapacity <- WaterContent_return[["FieldCapacity"]]
```

Where
OrgCfactor is Organic carbon factor,
SoilOrganicCPercent is Percentage of organic carbon in soil, by weight (%, SLC data table),
Clayfactor is Clay factor,
ClayContent is Proportion of clay in soil (SLC data table),
Sandfactor is Sand factor,
SandContent is Proportion of sand in soil (SLC data table),
WiltingPointPercent is Water content at wilting point (%),
WiltingPoint is Proportion of water content at wilting point (mm3 mm-3),
FieldCapacityPercent is Water content at field capacity (%), and
FieldCapacity is Proportion of water at field capacity (mm3 mm-3).


# Soil temperature

## Eq. 2.2.1-11
```{r}
SoilTopThickness = 250 #Constant (millimetres)
SoilMeanDepth = SoilTopThickness/20
```
## Eq. 2.2.1-12
```{r}
LeafAreaIndex = 0.8*GAI
```

# Surface temperature
Temperature is set according to the proper month in the climate normals.
```{r}
Temperature = daily_input_test$Tavg
```

##  Eq. 2.2.1-13 & Eq. 2.2.1-14
```{r}
SurfaceTemp <- ifelse(Temperature < 0, 0.20*Temperature,
											Temperature*(0.95+0.05*exp(-0.4*(LeafAreaIndex-3))))
```

Where
Temperature is Daily mean air temperature (˚C, by month - SLC data table), and
SurfaceTemp is Soil surface temperature (˚C).

# Soil Temperature
In order to recursively solve soil temperature, we first need to concatenate all of our calculated parameters that we have so far:
```{r}
daily_input_test <- bind_cols(daily_input_test,
															GAI = GAI,
															WiltingPoint = WiltingPoint,
															FieldCapacity = FieldCapacity,
															SoilTopThickness = SoilTopThickness,
															SoilMeanDepth = SoilMeanDepth,
															LeafAreaIndex = LeafAreaIndex,
															SurfaceTemp = SurfaceTemp)

```

## Sidenote 1: How do we handle recursive equations?
How are we able to recursively calculate soil temperature using the previous day's calculated soil temperature?
Our implementation is based on Dan Chaltiel's answer to this Stack Overflow question: https://stackoverflow.com/questions/67525729/recursive-lag-during-mutate

Inside the `mutate()` call, we are able to use the context-dependent expression `cur_data_all()` to cache the current iteration of the data.
This allows us to get the current row value for the column time using `db$time[row]`, and then multiply this by the previous value of the column we are accumulating.

```{r}
sidenote1 <- tibble(time = 1:5) %>%
	mutate(
		c = accumulate(.x=time, .f=function(acc, row) {
			db = cur_data_all()
			time = db$time[row]
			acc*time
			}) %>% unlist()
	)
sidenote1
```

## Eq. 2.2.1-15 & Eq. 2.2.1-16
Using the same method as above, we can `accumulate()` the value of `SoilTemp` using its value in the previous row (`SoilTemp_dprev`).
In this case, the name "accumulate" might lead to some confusion because the soil temperature goes both up and down over the course of the year.
The function `accumulate()` doesn't itself increase the value of of a variable, it just passes both the previous value and the current value of the variable into a function that you specify.

The function we are using in `accumulate()` here is `SoilTemp_d = SoilTemp_dprev + (SurfaceTemp-SoilTemp_dprev) * 0.24 * exp(-SoilMeanDepth*0.0174) * exp(-0.15*GAI)`

Where
SoilTemp is soil temperature (˚C), and
SoilTemp_dprev is soil temperature on the previous day (˚C).

```{r}
calculateSoilTemp
```


```{r}

SoilTemp <- calculateSoilTemp(daily_input_test)
```

<!-- Test weather data is from the NASA POWER database for a latitude and longitude approximately equal to the location of Ottawa Central Experimental Farm (45.3875035,-75.7113529 according to google maps) -->
<!-- ```{r} -->
<!-- climate_test_wheat1 <- readr::read_file("nasa_climate_data_lat_45.0024867523983_long_-74.9998855590822") %>% -->
<!-- 	as.geojson -->
<!-- zz <- tibble(climate_test_wheat1) -->
<!-- geo_pretty(climate_test_wheat1) -->
<!-- ``` -->

# Holos test r~e~ results


<!-- ```{r results = "asis"} -->
<!-- results_test_wheat1 <- readr::read_csv("wheat1.csv", skip=1) -->

<!-- table_test_wheat1 <- results_test_wheat1%>% -->
<!-- 	select(Farm, Field, Year, Crop, `Yield (kg ha^-1)`, `Moisture content (%)`, `Tillage type`, -->
<!-- 				 `Climate Factor (re_crop)`, `Tillage Factor (r_c)`, `Management factor (r_e)`) %>% -->
<!-- 	kable(caption="Holos results for the wheat1 test farm.") -->
<!-- table_test_wheat1 -->
<!-- ``` -->


# References
