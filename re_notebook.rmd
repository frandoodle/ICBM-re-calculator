---
title: "ICBM r~e~ Calculator Walkthrough"
author: "Francis Durnin-Vermette"
date: "2022/10/31"
output:
  html_notebook:
    toc: true
    number_sections: true
    df_print: paged
bibliography: re.bib
editor_options:
  chunk_output_type: inline
---

```{r include=FALSE}
library(ggplot2)
library(knitr)
library(dplyr)
library(geojson)
library(tibble)
library(purrr)
library(stringr)
library(here)
library(lubridate)
library(tidyr)

source("re_functions.r")

here::i_am("re_notebook.rmd")
```

# Input data

```{r}
holos_re <- readr::read_csv(here("holos_re_calculation.csv"))

daily_input_test <- tibble(
	Year = 2020,
	JulianDay = 1:365,
	Region = "QC",
	Yield = rep(3000, 365),
	perennial = rep(FALSE, 365),
	SoilOrganicC_Percent = rep(2, 365),
	ClayContent = rep(0.05, 365),
	SandContent = rep(0.2, 365),
	alfa = rep(0.7, 365)
) %>%
	mutate(Tavg = holos_re$InputTemperature,
				 PREC = holos_re$InputPrecipitation,
				 PET = holos_re$InputEvapotranspiration)
```



# Green area index (GAI) dynamics

## Eq. 2.2.1-1 through Eq. 2.2.1-3
```{r}
calculateGAI
```

where
`Yield` is the crop yield (kg dry matter ha-1),
`JulianDay` is the day,
`MidSeason` is the median day of growing season (Julian day),
`EmergenceDay` is the day of crop emergence (Julian day),
`RipeningDay` is the day of crop ripening (Julian day),
`GAI_max` is the maximum amplitude of green area index,
`GAI` is the green area index, and
`Variance` is the width of the distribution function

```{r}
GAI_return <- calculateGAI(daily_input_test)
GAI_return
GAI <- GAI_return[["GAI"]]
```



# Water content at wilting point and field capacity

## Eq. 2.2.1-4 through Eq. 2.2.1-10
```{r}
WaterContent_return <- calculateWaterContent(daily_input_test)
WaterContent_return
WiltingPoint <- WaterContent_return[["WiltingPoint"]]
FieldCapacity <- WaterContent_return[["FieldCapacity"]]
```

where
`OrgCfactor` is the organic carbon factor,
`SoilOrganicCPercent` is the percentage of organic carbon in soil, by weight (%, SLC data table),
`Clayfactor` is the clay factor,
`ClayContent` is the proportion of clay in soil (SLC data table),
`Sandfactor` is the sand factor,
`SandContent` is the proportion of sand in soil (SLC data table),
`WiltingPointPercent` is the water content at wilting point (%),
`WiltingPoint` is the proportion of water content at wilting point (mm3 mm-3),
`FieldCapacityPercent` is the water content at field capacity (%), and
`FieldCapacity` is the proportion of water at field capacity (mm3 mm-3).


# Soil temperature

## Eq. 2.2.1-11
```{r}
SoilTopThickness <- 250
SoilMeanDepth <- SoilTopThickness/20
```
## Eq. 2.2.1-12
```{r}
LeafAreaIndex <- 0.8*GAI
```

where
`SoilMeanDepth` is the Soil mean depth (mm),
`SoilTopThickness` is the thickness of top layer (mm), and
`LeafAreaIndex` is the leaf area index

# Surface temperature
Temperature is set according to the proper month in the climate normals.
```{r}
Temperature <- daily_input_test$Tavg
```

##  Eq. 2.2.1-13 & Eq. 2.2.1-14
```{r}
SurfaceTemp <- ifelse(Temperature < 0, 0.20*Temperature,
											Temperature*(0.95+0.05*exp(-0.4*(LeafAreaIndex-3))))
```

Where
`Temperature` is the daily mean air temperature (˚C, by month - SLC data table), and
`SurfaceTemp` is the soil surface temperature (˚C)

# Soil Temperature
In order to recursively solve soil temperature, we first need to concatenate all of our calculated parameters that we have so far:
```{r}
daily_input_test_soiltemp <- daily_input_test %>%
	full_join(GAI_return, by="JulianDay") %>%
	full_join(WaterContent_return, by="JulianDay") %>%
	bind_cols(SoilTopThickness = SoilTopThickness,
						SoilMeanDepth = SoilMeanDepth,
						LeafAreaIndex = LeafAreaIndex,
						SurfaceTemp = SurfaceTemp)

```

## Sidenote: How do we handle recursive equations?
How are we able to recursively calculate soil temperature using the previous day's calculated soil temperature?
Our implementation is based on Dan Chaltiel's answer to this Stack Overflow question: https://stackoverflow.com/questions/67525729/recursive-lag-during-mutate

Inside the `mutate()` call, we are able to use the context-dependent expression `cur_data_all()` to cache the current iteration of the data.
This allows us to get the current row value for the column time using `db$time[row]`, and then multiply this by the previous value of the column we are accumulating.

```{r}
sidenote1 <- tibble(time = 1:5) %>%
	mutate(
		c = accumulate(.x=time, .f=function(acc, row) {
			db = cur_data_all()
			time = db$time[row]
			acc*time
			}) %>% unlist()
	)
sidenote1
```

The reason we use this approach is because it lets us keep the functions vectorized

## Eq. 2.2.1-15 & Eq. 2.2.1-16
Using the same method as above, we can `accumulate()` the value of `SoilTemp` using its value in the previous row (`SoilTemp_dprev`).
In this case, the name "accumulate" might lead to some confusion because the soil temperature goes both up and down over the course of the year.
The function `accumulate()` doesn't itself increase the value of of a variable, it just passes both the previous value and the current value of the variable into a function that you specify.

The function we are using in `accumulate()` here is `SoilTemp_d = SoilTemp_dprev + (SurfaceTemp-SoilTemp_dprev) * 0.24 * exp(-SoilMeanDepth*0.0174) * exp(-0.15*GAI)`

```{r}
calculateSoilTemp
```
Where
`SoilTemp` is the soil temperature (˚C), and
`SoilTemp_dprev` is the soil temperature on the previous day (˚C)

```{r}
SoilTemp <- calculateSoilTemp(daily_input_test_soiltemp)
```

# Crop Evapotranspiration
## Eq. 2.2.1-17 & Eq. 2.2.1-18
```{r}
#Eq. 2.2.1-17
K_c <- 1.3 - (1.3-0.8) * exp(-0.17*GAI) 
```
```{r}
ET_0 <- daily_input_test$PET
#Eq. 2.2.1-18
ET_c <- ET_0 * K_c
```

where
`K_c` is the crop coefficient [@martelParsimoniousWaterBudget2021],
`ET_c` is the crop evapotranspiration under standard conditions (mm day-1), and
`ET_0` is the daily reference crop evapotranspiration (mm day-1), which should be calculated according to the FAO Penman-Monteith equation [@allenCropEvapotranspirationGuidelinesComputing1998]

# Irrigation
Irrigation can either be calculated using Eqs. 2.2.1-45 and 2.2.1-46, or specified by the user.

## Monthly distribution of irrigation (Table 7)
<span style="color: red;">
Question for Holos team: In Eq. 2.2.1-46, one of the terms is `(Irrigation_annual + Fraction_monthly)/Days_month`,
Is it meant to be `(Irrigation_annual * Fraction_monthly)/Days_month`?
</span>

From the Holos algorithm document:
"The proportion of the annual irrigation amount applied in each month and for each province is estimated as an average of values derived from the Agricultural Water Use Survey for 2010 and 2012 [@AgriculturalWaterUse2011; @AgriculturalWaterUse2013]".

```{r}
Irrigation_percentage_monthly <- tibble(
	`Province/Region` = c("Canada", "BC", "AB", "SK", "MB", "ON", "QC", "Atlantic Provinces"),
	`Jan` = 0,
	`Feb` = 0,
	`Mar` = 0,
	`Apr` = c(4.69, 8.00, 3.06, 15.08, 0.22, 3.81, 10.54, 7.30),
	`May` = c(4.69, 8.00, 3.06, 15.08, 0.22, 3.81, 10.54, 7.30),
	`Jun` = c(15.64, 19.54, 13.92, 14.80, 11.30, 18.35, 19.54, 10.62),
	`Jul` = c(38.96, 27.77, 42.65, 29.58, 48.15, 41.46, 32.24, 27.97),
	`Aug` = c(26.92, 25.66, 28.04, 19.40, 34.88, 26.74, 25.97, 34.06),
	`Sep` = c(4.56, 5.51, 4.63, 3.03, 2.61, 2.91, 2.71, 5.63),
	`Oct` = c(4.56, 5.51, 4.63, 3.03, 2.61, 2.91, 2.71, 5.63),
	`Nov` = 0,
	`Dec` = 0
) %>%
	mutate(Total = select(., where(is.numeric)) %>% rowSums())
Irrigation_percentage_monthly %>%
	kable(caption = "Percentage of total annual irrigation water applied by month for each province/region in Canada using average values across 2010 and 2012 (Adapted from Table 7 in the Holos algorithm document).")
```


The order of the equations has been changed from the original Holos algorithm document because irrigation is needed to calculate water balance.

## Eq. 2.2.1-45 & Eq. 2.2.1-46

```{r}
P <- sum(daily_input_test$PREC)
PE <- sum(daily_input_test$PET)
Region <- "QC"

Days_month <- lubridate::days_in_month(as.Date(paste(daily_input_test$Year, daily_input_test$JulianDay, sep="-"), "%Y-%j"))

Fraction_monthly <- Irrigation_percentage_monthly %>%
	filter(`Province/Region` == Region) %>%
	`[`(names(Days_month)) %>%
	unlist %>%
	`/`(100)

if (PE > P) {
	warning("Using Eqs. 2.2.1-45 and 2.2.1-46 to calculate default irrigation values")
	Irrigation_annual <- PE - P
	
	Irrigation <- ((Irrigation_annual * Fraction_monthly)/Days_month) %>%
		unname
} else {
	Irrigation <- 0
}

```
where
`PE` is the annual evapotranspiration (mm yr-1),
`P` is the annual precipitation (mm yr-1),
`Irrigation_annual` is the annual irrigation (mm yr-1),
`Fraction_monthly` is the assumed monthly distribution of irrigation (%) which is detailed in the next section,
`Days_month` is the number of days per month, and
`Irrigation` is the irrigation moisture input per day (mm d-1)

However, because Holos does not use the `if (PE > P)` conditional to assess whether irrigation should be added, we get a different result from the Holos version if we include irrigation. Therefore, for the sake of comparison, we remove the influence of irrigation.
```{r}
Irrigation <- 0
```


# Soil Available Water
<span style="color: red;">
Question for Holos team: In the original algorithm document, Eq. 2.2.1-19 is based on a conditional involving only precipitation, however Eq. 2.2.1-20 takes both precipitation and irrigation into account.
</span>

Here, we assume that both equations use both precipitation and irrigation into account in their conditional statements.


## Eq. 2.2.1-19 through Eq. 2.2.1-22
```{r}
Precipitation <- daily_input_test$PREC

#Eq. 2.2.1-19 - Eq. 2.2.1-20
CropInterception <- ifelse(Precipitation + Irrigation < 0.2*GAI,
													Precipitation + Irrigation,
													0.2*GAI)

#Eq. 2.2.1-21
CropInterception <- ifelse(CropInterception > ET_c, ET_c, CropInterception)

#Eq. 2.2.1-22
SoilAvailWater <- Precipitation + Irrigation - CropInterception
```
where
`CropInterception` is the crop interception of precipitation + irrigation (mm day-1),
`Precipitation` is the daily precipitation (mm day-1), and
`SoilAvailWater` is the soil available water (mm day-1)

# Water Balance

We need to make sure all the required inputs are in our input table:

```{r}
daily_input_test_waterstorage <- bind_cols(daily_input_test_soiltemp,
																					 SoilAvailWater = SoilAvailWater,
																					 ET_c = ET_c)
```

## Eq. 2.2.1-23 through Eq. 2.2.1-33
We use `mutate()` and `accumulate()` to vectorize water balance calculations.
We are interested in calculating topsoil water storage where the previous day's water storage is an input variable.

In order to calculate water storage, we use this function:
```{r}
calculateWaterStorage
```
where
`VolSoilWaterContent` is the volumetric soil water content  (mm3 mm-3),
`K_r` is the soil coefficient (dimensionless),
`alfa` is the minimum water storage fraction of WiltingPoint, and
`ET_a` is the actual evapotranspiration (mm day-1)
`WaterStorage_dprev` is the previous day's water storage in topsoil (mm day-1),
`WaterStorage_d` is the current day's water storage in topsoil (mm day-1), and
`DeepPerc` is the water lost to percolation down the soil profile (mm day^-1^)

```{r}
WaterStorage <- calculateWaterStorage(daily_input_test_waterstorage)
```

# Decomposition rate - effect of soil temperature
<span style="color: red;">
Question for Holos team: In Eq. 2.2.1-15, `SoilTemp_d = 0` if `JulianDay = 1`; what does this make `SoilTemp_dprev` on `JulianDay = 1`?
</span>

Here, we assume that `SoilTemp_dprev` and `SoilTemp_d` are both equal to 0 on `JulianDay = 1`.

## Eq. 2.2.1-34 & Eq. 2.2.1-35
```{r}
SoilTemp_dprev <- lag(SoilTemp, default=0)
Temp_min <- -3.78
Temp_max <- 30

# Eq. 2.2.1-34 - Eq. 2.2.1-35
re_temp <- ifelse(SoilTemp_dprev < -3.78, 0, ((SoilTemp_dprev - Temp_min)^2)/((Temp_max-Temp_min)^2))
```
where
`re_temp` is the temperature response factor,
`Temp_min` is the critical soil temperature (˚C), and
`Temp_max` is the maximum soil temperature (˚C)

# Decomposition rate - effect of soil moisture
## Eq. 2.2.1-36 through Eq. 2.2.1-41
```{r}
WaterStorage_dprev <- lag(WaterStorage, default = FieldCapacity[1]*SoilTopThickness)
VolSoilWaterContent <- calculateVolSoilWaterContent(WaterStorage_dprev, SoilTopThickness, WiltingPoint)

r_s <- 0.42
r_wp <- 0.18

# Eq. 2.2.1-36
VolSoilWaterContent_sat <- 1.2*FieldCapacity
# Eq. 2.2.1-37
VolSoilWaterContent_opt <- 0.9*FieldCapacity

# Eq. 2.2.1-38 - Eq. 2.2.1-40
re_water <- ifelse(
	# if...
	VolSoilWaterContent > VolSoilWaterContent_opt,
	# then...
	(1 - r_s)*((VolSoilWaterContent-VolSoilWaterContent_opt)/(VolSoilWaterContent_opt-VolSoilWaterContent_sat)) + 1, # Eq. 2.2.1-38
	ifelse(
		# elseif...
		VolSoilWaterContent < WiltingPoint,
		# then...
		r_wp*((VolSoilWaterContent)/(WiltingPoint)), # Eq. 2.2.1-39
		# else...
		(1-r_wp)*((VolSoilWaterContent-WiltingPoint)/(VolSoilWaterContent_opt-WiltingPoint)) + r_wp)) # Eq. 2.2.1-40

# Eq. 2.2.1-41
re_water <- pmin(pmax(0,re_water),1)
```
where
`VolSoilWaterContent_sat` is the volumetric soil water content at saturation level (mm3 mm-3),
`VolSoilWaterContent_opt` is the volumetric soil water content at optimal water content (mm3 mm-3),
`r_s` is the reference saturation (mm3 mm-3),
`r_wp` is the reference wilting point (mm3 mm-3), and
`re_water` is the moisture response factor

# Climate Factor (re~crop~)

## Eq. 2.2.1-42 through Eq. 2.2.1-44

In Holos, re~crop~ is calculated daily and then averaged annually.
```{r}
ReferenceAdjustment = 0.10516

# Eq. 2.2.1-42
re_x1 <- re_temp*re_water

# Eq. 2.2.1-43
re_cropdaily <- re_x1/ReferenceAdjustment

# Eq. 2.2.1-44
re_crop <- mean(re_cropdaily)
```
where
`re_x1` is the uncalibrated daily climate parameter,
`ReferenceAdjustment` is the calibration factor for a bare-fallow treatment considering a soil thickness of 25 cm (Uppsala, Sweden),
`re_cropdaily` is the daily climate parameter, and
`re_crop` is the climate parameter


# Tillage Factor (r~c~)
From the Holos algorithm document: "For the prairie provinces (Alberta, Saskatchewan, and Manitoba), changes in tillage management have been shown to influence soil carbon stocks. Accordingly, the tillage factor varies with soil type and tillage intensity."

For non-prairie provinces, `r_c = 1.0`,
for perennials, `r_c = 0.9` for the first year of planting; then the no-till factor is used for subsequent years,
for root crops in every province and soil zone, `r_c = 1.13`.
```{r}
tibble(`Soil type` = c("Brown", "Dark Brown", "Black"),
			 `Intensive Tillage` = c(1,1,1),
			 `Reduced tillage` = c(0.9, 0.85, 0.8),
			 `No-till` = c(0.8, 0.7, 0.6)) %>%
	kable(caption="r_c factor for Alberta, Saskatchewan, and Manitoba only (adapted from Holos algorithm document)")
```

```{r}
r_c <- 1
```


# Climate/management Factor (r~e~)

## Eq. 2.2.1-47

```{r}
r_edaily <- re_cropdaily*r_c
r_e <- mean(r_edaily)
r_e
```
where
`r_c` is the tillage factor, and
`re_cropdaily` is the daily climate/management factor,
`r_edaily` is the daily climate/management factor, and
`r_e` is the climate/management factor averaged for the year


# Testing R implementation of r~e~ against Holos implementation

## Test 1: this notebook vs. Holos
```{r echo=FALSE}
daily_input_test_all <- daily_input_test %>%
	bind_cols(Days_month = Days_month,
						Fraction_monthly = Fraction_monthly,
						Irrigation = Irrigation,
						
						GAI = GAI,
						
						SurfaceTemp = SurfaceTemp,
						SoilTemp = SoilTemp,
						
						K_c = K_c,
						ET_c = ET_c,
						Days_month = Days_month,
						Fraction_monthly = Fraction_monthly,
						Irrigation = Irrigation,
						CropInterception = CropInterception,
						SoilAvailWater = SoilAvailWater,
						WaterStorage = WaterStorage,
						SoilTemp_dprev = SoilTemp_dprev,
						WaterStorage_dprev = WaterStorage_dprev,
						VolSoilWaterContent = VolSoilWaterContent,
						
						
						re_temp = re_temp,
						re_water = re_water,
						re_x1 = re_x1,
						re_cropdaily = re_cropdaily,
						
						re_crop = re_crop,
						r_c = r_c,
						
						r_edaily = r_edaily,
						r_e = r_e)
```

```{r}
test_re <- daily_input_test_all %>%
	summarise(r_e = mean(r_e)) %>%
	unlist
```

```{r}
holos_re_calculation <- readr::read_csv(here("holos_re_calculation.csv")) %>%
	mutate(r_e = mean(ClimateParameter))
holos_re <- holos_re_calculation %>%
	summarise(r_e = mean(ClimateParameter)) %>%
	unlist
```
Now we can find the difference between the averaged yearly r_e values:
```{r}
PercentageDifference = 100*(holos_re - test_re)/holos_re

PercentageDifference
```
This means our R implementation of r~e~ is only `r PercentageDifference`% different from the r~e~ as calculated by Holos.

## Test 2: re_script.r vs. Holos

```{r}

```


# References
