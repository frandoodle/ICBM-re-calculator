---
title: "ICBM r~e~ Calculator Walkthrough"
author: "Francis Durnin-Vermette"
date: "2022/10/31"
output:
  html_notebook:
    toc: true
    number_sections: true
    df_print: paged
bibliography: re.bib
editor_options:
  chunk_output_type: inline
---

```{r include=FALSE}
library(ggplot2)
library(knitr)
library(dplyr)
library(geojson)
library(tibble)
library(purrr)
library(stringr)
library(here)

source("re_functions.r")

here::i_am("re_notebook.rmd")
```

# Climate data
We use the monthly climate normals that are shipped with Holos V4 in order to make our first calculations.

To use these, we need to specify an SLC polygon.
We arbitrarily choose SLC poly #1001009 for this.
```{r}
slc = 1001009
climate_test_norms1 <- readr::read_csv("climate/climateNorms_by_poly_1980_2010.csv") %>%
	filter(SLC == slc)
climate_test_norms1 %>%
	kable(caption="Climate normals for SLC polygon 1001009 for the period 1980 - 2010.")
```

## Test input data
For our first test, let's say our crop is an annual with Yield = 3000.
```{r}
climate_data_monthly <- climate_test_norms1

daily_input_test <- tibble(
	JulianDay = 1:365,
	Yield = rep(3000, 365),
	perennial = rep(FALSE, 365),
	SoilOrganicC_Percent = rep(12, 365),
	ClayContent = rep(0.05, 365),
	SandContent = rep(0.2, 365)
) %>%
	rowwise() %>%
	#add climate data to the input thing
	mutate(Tavg = filter(climate_data_monthly, month==ceiling(JulianDay/30.4375))$Tavg,
				 PREC = filter(climate_data_monthly, month==ceiling(JulianDay/30.4375))$PREC,
				 PET = filter(climate_data_monthly, month==ceiling(JulianDay/30.4375))$PET) %>%
	ungroup()
```



# Green area index (GAI) dynamics

## Eq. 2.2.1-1 through Eq. 2.2.1-3
```{r}
GAI_return <- calculateGAI(daily_input_test)
GAI_return
GAI <- GAI_return[["GAI"]]
```

Where
GAImax is Maximum amplitude of green area index, 
Yield is Crop yield (kg dry matter ha-1, database default or user specific),
MidSeason is Median day of growing season (Julian day),
EmergenceDay is Day of crop emergence (Julian day),
RipeningDay is Day of crop ripening (Julian day),
GAI is Green area index,
JulianDay is Day (Julian day), and
Variance is Width of distribution function.

# Water content at wilting point and field capacity

## Eq. 2.2.1-4 through Eq. 2.2.1-10
```{r}
WaterContent_return <- calculateWaterContent(daily_input_test)
WaterContent_return
WiltingPoint <- WaterContent_return[["WiltingPoint"]]
FieldCapacity <- WaterContent_return[["FieldCapacity"]]
```

Where
OrgCfactor is Organic carbon factor,
SoilOrganicCPercent is Percentage of organic carbon in soil, by weight (%, SLC data table),
Clayfactor is Clay factor,
ClayContent is Proportion of clay in soil (SLC data table),
Sandfactor is Sand factor,
SandContent is Proportion of sand in soil (SLC data table),
WiltingPointPercent is Water content at wilting point (%),
WiltingPoint is Proportion of water content at wilting point (mm3 mm-3),
FieldCapacityPercent is Water content at field capacity (%), and
FieldCapacity is Proportion of water at field capacity (mm3 mm-3).


# Soil temperature

## Eq. 2.2.1-11
```{r}
SoilTopThickness = 250 #Constant (millimetres)
SoilMeanDepth = SoilTopThickness/20
```
## Eq. 2.2.1-12
```{r}
LeafAreaIndex = 0.8*GAI
```

# Surface temperature
Temperature is set according to the proper month in the climate normals.
```{r}
Temperature = daily_input_test$Tavg
```

##  Eq. 2.2.1-13 & Eq. 2.2.1-14
```{r}
SurfaceTemp <- ifelse(Temperature < 0, 0.20*Temperature,
											Temperature*(0.95+0.05*exp(-0.4*(LeafAreaIndex-3))))
```

Where
Temperature is Daily mean air temperature (˚C, by month - SLC data table), and
SurfaceTemp is Soil surface temperature (˚C).

# Soil Temperature
In order to recursively solve soil temperature, we first need to concatenate all of our calculated parameters that we have so far:
```{r}
daily_input_test <- bind_cols(daily_input_test,
															GAI = GAI,
															WiltingPoint = WiltingPoint,
															FieldCapacity = FieldCapacity,
															SoilTopThickness = SoilTopThickness,
															SoilMeanDepth = SoilMeanDepth,
															LeafAreaIndex = LeafAreaIndex,
															SurfaceTemp = SurfaceTemp)

```

## Sidenote 1: How do we handle recursive equations?
How are we able to recursively calculate soil temperature using the previous day's calculated soil temperature?
Our implementation is based on Dan Chaltiel's answer to this Stack Overflow question: https://stackoverflow.com/questions/67525729/recursive-lag-during-mutate

Inside the `mutate()` call, we are able to use the context-dependent expression `cur_data_all()` to cache the current iteration of the data.
This allows us to get the current row value for the column time using `db$time[row]`, and then multiply this by the previous value of the column we are accumulating.

```{r}
sidenote1 <- tibble(time = 1:5) %>%
	mutate(
		c = accumulate(.x=time, .f=function(acc, row) {
			db = cur_data_all()
			time = db$time[row]
			acc*time
			}) %>% unlist()
	)
sidenote1
```

## Eq. 2.2.1-15 & Eq. 2.2.1-16
Using the same method as above, we can `accumulate()` the value of `SoilTemp` using its value in the previous row (`SoilTemp_dprev`).
In this case, the name "accumulate" might lead to some confusion because the soil temperature goes both up and down over the course of the year.
The function `accumulate()` doesn't itself increase the value of of a variable, it just passes both the previous value and the current value of the variable into a function that you specify.

The function we are using in `accumulate()` here is `SoilTemp_d = SoilTemp_dprev + (SurfaceTemp-SoilTemp_dprev) * 0.24 * exp(-SoilMeanDepth*0.0174) * exp(-0.15*GAI)`

Where
SoilTemp is soil temperature (˚C), and
SoilTemp_dprev is soil temperature on the previous day (˚C).

```{r}
calculateSoilTemp
```


```{r}
SoilTemp <- calculateSoilTemp(daily_input_test)
```

# Water Balance
We use the same approach of recursive `mutate()` and `accumulate()` for water balance calculations.
We are interested in calculating topsoil water storage where the previous day's water storage is an input variable.

## Crop Evapotranspiration
```{r}
#Eq. 2.2.1-17
K_c = 1.3 - (1.3-0.8) * exp(-0.17*GAI) 
```
```{r}
ET_0 = daily_input_test$PET
#Eq. 2.2.1-18
ET_c = ET_0 * K_c
```

where
K_c is Crop coefficient [@martelParsimoniousWaterBudget2021],
ET_c is Crop evapotranspiration under standard conditions (mm day-1), and
ET_0 is Daily reference crop evapotranspiration (mm day-1), which should be calculated according to the FAO Penman-Monteith equation [@allenCropEvapotranspirationGuidelinesComputing1998].

## Soil Available Water
There is something unclear here: In the original algorithm document, Eq. 2.2.1-19 is based on a conditional involving only precipitation, however Eq. 2.2.1-20 takes both precipitation and irrigation into account.
Here, we make the assumption that both equations should take both precipitation and irrigation into account in their conditional statements.

```{r}
Precipitation = daily_input_test$PREC

Irrigation = rep(0,365)

#Eq. 2.2.1-19 - Eq. 2.2.1-20
CropInterception = ifelse(Precipitation + Irrigation < 0.2*GAI,
													Precipitation + Irrigation,
													0.2*GAI)

#Eq. 2.2.1-21
CropInterception <- ifelse(CropInterception > ET_c, ET_c, CropInterception)

#Eq. 2.2.1-22
SoilAvailWater = Precipitation + Irrigation - CropInterception
```

```{r}
calculateVolSoilWaterContent <- function(InputTable) {
	#Input should be a df/tibble with the columns
	#JulianDay (int) (these values need to be contiguous or else the function doesn't work),
	#SoilTopThickness (float)
	#WiltingPoint (float)
	VolSoilWaterContent = InputTable %>%
		#Subtract JulianDay by its first value to get 0.
		#Since accumulate() takes .init from .x[[1]], this sets the initial value to 0 (Eq. 2.2.1-15).
		mutate(d = accumulate(.x = JulianDay, .f=function(WaterStorage_dprev, row) {
			data = cur_data_all()
			
			print(row)
			if(row == 1) {print(WaterStorage_dprev)}
			
			SoilTopThickness = data$SoilTopThickness[row]
			WiltingPoint = data$WiltingPoint[row]
			
			#Eq. 2.2.1-23 to 2.2.1-24
			VolSoilWaterContent = WaterStorage_dprev/SoilTopThickness
			if (VolSoilWaterContent == 0) {
				VolSoilWaterContent = WiltingPoint
			}
			
			return(VolSoilWaterContent)
			
		}))
	
	return(VolSoilWaterContent$d)
}

calculateVolSoilWaterContent(daily_input_test)

#Eq. 2.2.1-23
VolSoilWaterContent = WaterStorage_dprev/SoilTopThickness
#Eq. 2.2.1-24
if(VolSoilWaterContent <= 0) {
	VolSoilWaterContent = WiltingPoint
}
```
where
CropInterception is Crop interception of precipitation + irrigation (mm day-1),
Precipitation is Daily precipitation + irrigation (mm day-1 - SLC data table),
SoilAvailWater is Soil available water (mm day-1),
VolSoilWaterContent is Volumetric soil water content  (mm3 mm-3),
WaterStorage_dprev is Water storage in topsoil (mm day-1) calculated previous day in Eq. 2.1.1-29 or Eq. 2.1.1-30

## Actual Evapotranspiration
```{r}
alfa = 0.7 #constant
#Eq. 2.2.1-25
K_r = (1 - ((0.95 * FieldCapacity - VolSoilWaterContent)/(0.95 * FieldCapacity - alfa*WiltingPoint)))^2

#Eq. 2.2.1-26
K_r = min(max(0,K_r),1)

#Eq. 2.2.1-27
if(VolSoilWaterContent < alfa/100*WiltingPoint) {
	K_r = 0
}

#Eq. 2.2.1-28
ET_a = ET_c * K_r
```
where
K_r is Soil coefficient (dimensionless),
alfa is Minimum water storage fraction of WiltingPoint, and
ET_a is Actual evapotranspiration (mm day-1)

## Water Storage
```{r}
if(JulianDay == 1) {
	WaterStorage_dprev = FieldCapacity*SoilTopThickness
	WaterStorage_d = FieldCapacity*SoilTopThickness
} else {
	DeepPerc = WaterStorage_dprev - FieldCapacity*SoilTopThickness
	ifelse(DeepPerc<0,0,DeepPerc)
	WaterStorage_d = WaterStorage_dprev + SoilAvailWater - ET_a - DeepPerc
}
```
where
DeepPerc is Water lost to percolation down the soil profile (mm day^-1^)

# Decomposition rate - effect of soil temperature

# Decomposition rate - effect of soil moisture

# Climate Factor (re_crop)

# Tillage Factor (rc)

# Irrigation

# Climate/management Factor (re)

<!-- Test weather data is from the NASA POWER database for a latitude and longitude approximately equal to the location of Ottawa Central Experimental Farm (45.3875035,-75.7113529 according to google maps) -->
<!-- ```{r} -->
<!-- climate_test_wheat1 <- readr::read_file("nasa_climate_data_lat_45.0024867523983_long_-74.9998855590822") %>% -->
<!-- 	as.geojson -->
<!-- zz <- tibble(climate_test_wheat1) -->
<!-- geo_pretty(climate_test_wheat1) -->
<!-- ``` -->

# Testing r~e~ against Holos implementation


<!-- ```{r results = "asis"} -->
<!-- results_test_wheat1 <- readr::read_csv("wheat1.csv", skip=1) -->

<!-- table_test_wheat1 <- results_test_wheat1%>% -->
<!-- 	select(Farm, Field, Year, Crop, `Yield (kg ha^-1)`, `Moisture content (%)`, `Tillage type`, -->
<!-- 				 `Climate Factor (re_crop)`, `Tillage Factor (r_c)`, `Management factor (r_e)`) %>% -->
<!-- 	kable(caption="Holos results for the wheat1 test farm.") -->
<!-- table_test_wheat1 -->
<!-- ``` -->


# References
